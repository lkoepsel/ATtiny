# Programming the ATtiny13A in Standard C

Notes as to developing C code for the Microchip ATtiny13A. *Some* of this content was generated by Claude Opus 4 in June 2025. **That said, many errors have been found and I'm concerned there might still be a few lurking. Trust but verify.**

## Datasheets and Information

* [Microchip ATtiny13A](https://www.microchip.com/en-us/product/attiny13a)
* [ATtiny13A-Data-Sheet-DS40002307A](https://ww1.microchip.com/downloads/en/DeviceDoc/ATtiny13A-Data-Sheet-DS40002307A.pdf) and [*local*](https://github.com/lkoepsel/ATtiny/blob/main/documentation/ATtiny13A-Data-Sheet-DS40002307A.pdf)
* [Efficient C Coding for 8-bit AVR Processors](https://www.microchip.com/en-us/application-notes/an1497) and [*local*](https://github.com/lkoepsel/ATtiny/blob/main/documentation/Atmel-AVR035-Efficient%20C%20Coding%20for%20AVR.pdf)
* [*C* (ANSI C99) AVR-LibC](https://github.com/avrdudes/avr-libc)
* [GDB Online Manual](https://sourceware.org/gdb/current/onlinedocs/gdb.html/index.html#Top) and [*local*](https://github.com/lkoepsel/ATtiny/blob/main/documentation/gdb_17.0.50.20250617-git.pdf)
* [Bloom Documentation](https://bloom.oscillate.io/docs/getting-started)
* [Bloom Target Information](https://bloom.oscillate.io/docs/target/attiny13a)
* [Arduino Sensors](https://arduinomodules.info)

## docs

### Table of Contents

#### [env_make.md](./docs/env_make.md)
The file env_make is used to customize the *make* process for *ATtiny* development. It is **required** in order for make to properly identify the parameters needed for compiling/linking/uploading executable code to an AVR microcontroller. **This file is not tracked by *git* and needs to be installed manually.** 

#### [vs_code.md](./docs/vs_code.md)
This page contains the files needed to be more efficient with *VS Code*. Install them inot the *.vscode* folder of *ATtiny*. They are not tracked by *git*.

#### [git.md](./docs/git.md)
Notes on using *git*. I am neither an expert on *git* nor proficient in *git*. This page is primarily for myself, however, it has helped a few people.

#### [RPI_build.md](https://github.com/lkoepsel/AVR_C/blob/main/docs/RPi_build.md) - see this  in the AVR_C repository
If you want to use a Raspberry Pi (3/4/5) as a C development platform, this page is for you! Highly detailed, it will show every step required to build the latest software for developing C on an AVR microcontroller. Have fun! 

#### [bloom and gdb.md](./docs/bloomandgdb.md)
Given the ATtiny13A requires a hardware interface to load software, I recommend using *bloom* as the interface to avr-gdb. This provides loading and debugging capability, which is required to be successful. 

#### [PWM and ADC.md](./docs/PWMandADC.md)
Page under development to explain PWM and ADC interaction. 

## Introduction
This repository provides example programs in  [*C* (ANSI C99) AVR-LibC](https://github.com/avrdudes/avr-libc) which support programming the ATtiny13A.

In order to use this framework, you can either install the *GNU avr* tool chain appropriate for your computer (Linux, macOS, or Windows). 

Because there is not a boot loader for the ATtiny13A due to memory constraints, you will need to use an ATMEL-ICE or Microchip SNAP to load programs. The *env.make* allows for this, with entries for both.

 I also recommend using [Bloom](https://bloom.oscillate.io/) and *avr-gdb*. Bloom provides the ability to load code as well as display the microcontroller's registers and memory. More details specific to the *ATTiny13A*, **bloom**, and *gdb* at the [bottom of this page](#using-bloom-and-avr-gdb).

[gdb](https://www.sourceware.org/gdb/) is a simple yet extremely powerful debugging tool. I find it easier to use than most IDE's such as Visual Studio, MPLAB IDE etc. More guidance at [Developing in C for the ATmega328: Setup Bloom and gdb for Hardware Debug](https://wellys.com/posts/avr_c_gdb_bloomsetup/). 

## Steps to Use
1. Install toolchain. [Details here](https://www.wellys.com/posts/avr_c_setup/). The **best** method is to use a [Raspberry Pi as your development platform.](./docs/RPi_build.md)
2. Clone this repository, [use git and clone to your system](https://www.wellys.com/posts/avr_c_step5/).
3. Open the *ATtiny* folder and add an *env.make* file (*see below*) based on your board and system.
4. Navigate to *examples/blink* in your CLI and run:
	* *make* to compile, link and create an executable file
	* *make flash* to upload executable file to your board.
5. Look at the other examples to better understand how to use the code and begin writing your own!

## Programming Summary

### Note:
1. *PB3* and *PB4* are available using *ISP* programmer
1. *PB0-PB4* are available using *debugWire*
1. Bloom requires specific functionality of the ISP interface. Connect via ISP then use debugWire for debugging and loading programs. 
   From Bloom: "*The debugWIRE interface does not support fuse programming. Fuses can only be changed via the ISP interface (for debugWIRE AVR targets). In order for Bloom to manage the DWEN fuse bit, the debug tool must be connected to the target via the ISP interface.*"
1. **Therefore, it's best to use *load* and *mon reset* within *avr-gdb* instead of using AVRDUDE, when connected using the ATMEL ICE or Microchip SNAP.** 
1. The arrow on the ATMEL ICE ISP connector is incorrect. Pin 3 (middle pin) is at the notch.

### ATtiny13A Pinout
```
                    ATtiny13
                  ┌──────────┐
    RESET/PB5 ──1─┤          ├─8── VCC
          PB3 ──2─┤          ├─7── PB2/SCK
          PB4 ──3─┤          ├─6── PB1/MISO
          GND ──4─┤          ├─5── PB0/MOSI
                  └──────────┘
```

| ISP Pin | ATtiny13A  | **13A Pin**  | Uno ISP | Color  |
|---------|------------|------------| ------- | ------ |
| RESET   | PB5/RESET  | **Pin 1**    | Pin 5   | Brown  |  
| GND     | GND        | **Pin 4**    | Pin 6   | Black  |
| MOSI    | PB0        | **Pin 5**    | Pin 4   | Green  |
| MISO    | PB1        | **Pin 6**    | Pin 1   | Yellow |
| SCK     | PB2        | **Pin 7**    | Pin 3   | Orange |
| VCC     | VCC        | **Pin 8**    | Pin 2   | Red    |


### ATtiny13A ISP Connections

```
                ISP Header (2x3)
              +-------+-------+
MISO/YELLOW --| 1  ●     ●  2 |--- VCC/RED
            |         |       |
SCK/ORANGE -| 3  ●       ●  4 |--- MOSI/GREEN
            |         |       |
RESET/BROWN --| 5  ●     ●  6 |--- GND/BLACK
              +-------+-------+
                  |||||||
                  ||||||+-- Pin 6: GND
                  |||||+--- Pin 5: RESET
                  ||||+---- Pin 4: MOSI
                  |||+----- Pin 3: SCK
                  ||+------ Pin 2: VCC (+5V)
                  |+------- Pin 1: MISO
                  +-------- Notch/Key (orientation)
```

## Port B Pin Functionality

| 13A PDIP | Port Pin | Alternate Functions |
| --- |----------|-------------------|
|  1  | **PB5** | • RESET: Reset Pin<br>• dW: debugWIRE I/O<br>• ADC0: ADC Input Channel 0<br>• PCINT5: Pin Change Interrupt, Source 5 |
|  3  | **PB4** | • ADC2: ADC Input Channel 2<br>• PCINT4: Pin Change Interrupt 0, Source 4 |
|  2  | **PB3** | • CLKI: External Clock Input<br>• ADC3: ADC Input Channel 3<br>• PCINT3: Pin Change Interrupt 0, Source 3 |
|  7  | **PB2** | • SCK: Serial Clock Input<br>• ADC1: ADC Input Channel 1<br>• T0: Timer/Counter0 Clock Source<br>• PCINT2: Pin Change Interrupt 0, Source 2 |
|  6  | **PB1** | • MISO: SPI Host Data Input / Client Data Output<br>• AIN1: Analog Comparator, Negative Input<br>• OC0B: Timer/Counter0 Compare Match B Output<br>• INT0: External Interrupt 0 Input<br>• PCINT1: Pin Change Interrupt 0, Source 1 |
|  5  | **PB0** | • MOSI: SPI Host Data Output / Client Data Input<br>• AIN0: Analog Comparator, Positive Input<br>• OC0A: Timer/Counter0 Compare Match A output<br>• PCINT0: Pin Change Interrupt 0, Source 0 |

## ADC Features
* 4 Channels PinB2-5
* 1 Analog Comparator PB0-1
* 10-bit resolution
* 260us conversion time (*longest*)

### **Power Supply Components**
- **VCC**: Connect to pin 8 (supply voltage: 2.7V to 5.5V)
- **GND**: Connect to pin 4
- **Decoupling capacitor**: 100nF ceramic capacitor between VCC and GND, placed as close to the chip as possible

### **Programming Interface**

Required by **bloom** to change fuses, specifically setting *DWEN* to use *debugWire* interface.

For In-System Programming (ISP), connect:
- **MISO** (PB1) - Pin 6
- **MOSI** (PB0) - Pin 5  
- **SCK** (PB2) - Pin 7
- **RESET** (PB5) - Pin 1
- **VCC** and **GND** from programmer

### **Minimal Working Circuit**
1. Connect **VCC** (pin 8) to your power supply (2.7-5.5V)
2. Connect **GND** (pin 4) to ground
3. Add **100nF decoupling capacitor** between VCC and GND
5. Connect ISP header for programming

## **Hardware Requirements for DebugWire**

### **Modified Reset Pin Configuration**
- If exists, **remove the 10kΩ pull-up resistor** from the RESET pin (pin 1)
- The RESET pin becomes a **bidirectional communication line** when DebugWire is enabled
- Keep the reset line as short as possible to minimize noise

### **Simplified Connection**
When using DebugWire, you need:
- **RESET/dW** (pin 1) - Connected to debugger
- **VCC** (pin 8) - Power supply
- **GND** (pin 4) - Ground
- **100nF decoupling capacitor** between VCC and GND

### **Important Considerations**

1. **Fuse Configuration**
   - You must **enable the DWEN (DebugWire Enable) fuse bit**
   - Once enabled, the RESET pin loses its reset functionality and becomes a DebugWire interface
   - ISP programming is disabled when DebugWire is active
   - **Bloom does this quite well, leave it to Bloom**

2. **Debugger Requirements**
   - Use a compatible debugger like **Atmel-ICE**, **Microchip SNAP**, or **AVR Dragon**
   - The debugger must support DebugWire protocol

3. **Power Cycling**
   - After enabling DebugWire, you need to **power cycle** the target device
   - The debugger will then communicate through the single-wire interface

### **To Disable DebugWire**
If you need to return to normal ISP programming:
1. Use the debugger to **disable DebugWire** through the debugging software
2. Or perform a **high-voltage programming** sequence to clear the DWEN fuse
3. This restores the RESET pin functionality

Remember that while DebugWire provides powerful debugging capabilities with just one wire, it **temporarily disables normal ISP programming** until you explicitly disable the DebugWire mode.

## Simple Blink Program (examples/blink_avr)

```c
//  blink_avr - uses bit setting by registers instead of digitalWrite()
//  version uses PB3 as PB5, doubles as debugWire on ATtiny13A
//  for smallest code size, set LIBRARY = no_lib in env.make 
//   Smallest code size allows you to use a scope to confirm delay 
//   is exactly 1 millisecondor other timing exercises.
//   For example: (when measured):
//   blink 2.0108s period while avr_blink 2.0022s period for a delay of 1000ms
//   or remove the delays and determine fastest blink is 2.02MHz w/ -Og -ggdb
//   or remove the delays and determine fastest blink is 2.68MHz w/ -Os -g

#include <avr/io.h>
#include <util/delay.h>
 
#define BLINK_DELAY_MS 1000
 
int main(void)
{
    /* set pin to output*/
    DDRB |= (_BV(PORTB3));

    while(1) 
    {
        /* turn led on and off */
        PINB |= (_BV(PORTB3));
        _delay_ms(BLINK_DELAY_MS);
        PINB |= (_BV(PORTB3));
        _delay_ms(BLINK_DELAY_MS);
    }
    return 0; 
}
```

## Compilation Steps

### Step 1: Confirm env.make
```bash
# Environmental variables for ATtiny13A with ATMEL-ICE
# MCU = attiny13a
# SERIAL = /dev/ttyACM0
# F_CPU = 1200000UL
# USB_BAUD = 250000UL
# LIBDIR = $(DEPTH)Library
# LIBRARY = no_lib
# PROGRAMMER_TYPE = atmelice_isp
# PROGRAMMER_ARGS = -F -V -P usb -b 115200
# TOOLCHAIN =
# OS =

# Environmental variables for ATtiny13A with SNAP
# Low Fuse CKDIV8 has been set to 1 for a 9.6MHZ clock
MCU = attiny13a
SERIAL = /dev/ttyACM0
F_CPU = 1200000UL
USB_BAUD = 250000UL
LIBDIR = $(DEPTH)Library
LIBRARY =
PROGRAMMER_TYPE = snap_isp
PROGRAMMER_ARGS = -F -V -P usb -b 115200
TOOLCHAIN =
OS =

```

### Step 2: Check compilation
```bash
make complete
```

### Step 3: Attach ATMEL ICE (or [SNAP](#microchip-snap-programmer))

Connect your **ISP programmer** to the ATtiny13A:

| ISP Pin | ATtiny13A  | 13A Pin  | Uno ISP | Color  |
|---------|------------|----------| ------- | ------ |
| VCC     | VCC        | Pin 8    | Pin 2   | Red    |
| GND     | GND        | Pin 4    | Pin 6   | Black  |
| MISO    | PB0        | Pin 6    | Pin 1   | Yellow |
| MOSI    | PB1        | Pin 5    | Pin 4   | Green  |
| SCK     | PB2        | Pin 7    | Pin 3   | Orange |
| RESET   | PB5/RESET  | Pin 1    | Pin 5   | Brown  |  

### Step 4: Check Program Size (Optional)
```bash
make size
```

### Step 5: Upload Program

```bash
make flash
```

## Fuse Configuration (Optional)

The **ATtiny13A** comes with default fuse settings for 1.2MHz internal oscillator. To change clock settings:

### Read Current Fuses
```bash
avrdude -c atmelice_isp -p attiny13a -U lfuse:r:-:h -U hfuse:r:-:h
```

### Common Fuse Settings

**9.6MHz Internal Oscillator:**
```bash
avrdude -c atmelice_isp -p attiny13a -U lfuse:w:0x7A:m -U hfuse:w:0xFF:m
```

**4.8MHz Internal Oscillator:**
```bash
avrdude -c atmelice_isp -p attiny13a -U lfuse:w:0x79:m -U hfuse:w:0xFF:m
```

⚠️ **Warning:** Be careful with fuse settings! Incorrect values can brick your chip.

## Troubleshooting

**"Device signature = 0x000000" error:**
- Check wiring connections
- Verify power supply
- Try slower programming speed: ```-B 10```

**"Initialization failed" error:**
- Ensure programmer drivers are installed
- Check USB connection
- Verify programmer type in avrdude command

**LED not blinking:**
- Verify LED polarity and resistor value
- Check if correct pin is used in code
- Ensure F_CPU matches actual clock frequency

### Alternative Programmer Types for Atmel-ICE
The Atmel-ICE supports multiple programming modes:
- **ISP mode**: ```-c atmelice_isp```
- **debugWIRE**: ```-c atmelice_dw```

## Microchip SNAP Programmer

### Basic Terminal Command
```bash
avrdude -c snap_isp -p attiny13a -t
```

### Basic Flash Command
```bash
avrdude -c snap_isp -p attiny13a -U flash:w:main.hex:i
# better method
make flash
```

### With Port Specification
```bash
avrdude -c snap_isp -p attiny13a -P usb -U flash:w:main.hex:i
```

### Connection Speed
Both programmers may benefit from specifying a bit clock rate, especially for targets with slow clocks:
```bash
# For Atmel-ICE
avrdude -c atmelice_isp -p attiny13a -B 10 -U flash:w:blink.hex:i

# For SNAP
avrdude -c snap_isp -p attiny13a -B 10 -U flash:w:blink.hex:i
```

The ```-B``` parameter sets the ISP clock period in microseconds.

### Voltage Settings
The **SNAP programmer doesn't provide target power**, so you must power the ATtiny13A externally. The Atmel-ICE can provide power, but it's often better to use external power.

## Troubleshooting Specific to These Programmers

### Atmel-ICE Issues
- **"No Atmel-ICE units found"**: Check USB drivers, may need to install **libusb** on Linux
- **Connection issues**: Try adding ```-B 10``` to slow down ISP clock
- **Permission errors on Linux**: Add udev rules or run with sudo

### SNAP Issues
- **"Cannot find SNAP"**: Update to latest AVRDUDE version
- **Power issues**: Remember SNAP doesn't supply power - **external power required**
- **Slower programming**: SNAP can be slower than other programmers; this is normal

### Linux USB Permissions
For both programmers on Linux, you may need to add udev rules:

Create ```/etc/udev/rules.d/99-atmel.rules```:
```bash
# Atmel-ICE
SUBSYSTEM=="usb", ATTRS{idVendor}=="03eb", ATTRS{idProduct}=="2141", MODE="0666"

# Microchip SNAP
SUBSYSTEM=="usb", ATTRS{idVendor}=="03eb", ATTRS{idProduct}=="2180", MODE="0666"
```

Then reload rules:
```bash
sudo udevadm control --reload-rules
sudo udevadm trigger
```

## Understanding the Clock frequencies

The ATtiny13A has an internal RC oscillator that can run at either 4.8MHz or 9.6MHz. There is a clock divider (CLKDIV8) that is enabled by default from the factory, which divides the clock by 8. So:

- Default factory setting: 9.6MHz oscillator with CLKDIV8 enabled = 1.2MHz system clock or *1.2MHz is the default system clock frequency after the divider*

The oscillator runs at 9.6MHz but the system clock is 1.2MHz by default due to the divider.

To run at 9.6MHz, you need to:
1. Keep the oscillator at 9.6MHz (which is already the default)
2. Disable the CLKDIV8 fuse

## ATtiny13A Clock System Explanation

The **ATtiny13A** has an internal RC oscillator that runs at either:
- **9.6MHz** (default oscillator setting)
- **4.8MHz** (alternative setting)

However, there's a crucial detail: the **CLKDIV8 fuse is programmed by default** from the factory, which divides the clock by 8.

- **Default from factory**: 9.6MHz ÷ 8 = **1.2MHz system clock**

## Fuse Settings for Different Frequencies

### To Run at 9.6MHz System Clock

**This command is correct. Performed as shown below and it works. You need to **disable CLKDIV8** (unprogram the fuse bit):**

```bash
## write CLKDIV8 (bit 4) a 1 meaning unprogrammed, in this case DWEN (bit 3 H fuse) was already programmed
avrdude -c snap_isp -p attiny13a -U lfuse:w:0x7A:m -U hfuse:w:0xF7:m
# read the fuses back
avrdude -c snap_isp -p attiny13a -U lfuse:r:-:h -U hfuse:r:-:h
# be sure to set CPU speed in env.make to 9600000UL
```

**Low Fuse (0x7A) breakdown: CONFIRMED**
- Bits 7 = 0 SPIEN (programmed - SPI prog. enabled)
- Bits 6 = 1 EESAVE (Preserve EEPROM memory through
Chip Erase)
- Bits 5 = 1 WDTON (Watchdog Timer always on)
- Bits 4 = 0 CKDIV8 (Divide clock by 8)
- Bits 3 = 1 SUT1 (Start-up time)
- Bits 2 = 0 SUT0 (Start-up time)
- Bits 1 = 1 CKSEL1 (Select clock source)
- Bits 0 = 0 CKSEL0 (Select clock source)

### To Run at 4.8MHz System Clock UNCONFIRMED

```bash
avrdude -c atmel- -p attiny13a -U lfuse:w:0x79:m -U hfuse:w:0xFF:m
```

**Low Fuse (0x79) breakdown:**
- Bits 7:6 = 01 (CKDIV8 unprogrammed)
- Bits 1:0 = 01 (4.8MHz internal oscillator)

### To Run at 1.2MHz System Clock (Factory Default)

```bash
avrdude -c atmelice_isp -p attiny13a -U lfuse:w:0x6A:m -U hfuse:w:0xFF:m
```

**Low Fuse (0x6A) breakdown:**
- Bits 7:6 = 00 (CKDIV8 programmed - clock divided by 8)
- Bits 1:0 = 10 (9.6MHz ÷ 8 = 1.2MHz)

### Compile for 9.6MHz

Update the Makefile:
```makefile
F_CPU = 9600000UL  # 9.6MHz instead of 1200000UL
```

## Reading Current Fuse Settings

To check your current fuse configuration:

```bash
avrdude -c atmelice_isp -p attiny13a -U lfuse:r:-:h -U hfuse:r:-:h
```

**Default factory values:**
- Low Fuse: **0x6A**
- High Fuse: **0xFF**

## Complete Fuse Reference

| Clock Speed | Low Fuse | CLKDIV8 | Oscillator |
|-------------|----------|----------|------------|
| 9.6MHz      | 0x7A     | Disabled | 9.6MHz     |
| 4.8MHz      | 0x79     | Disabled | 4.8MHz     |
| 1.2MHz      | 0x6A     | Enabled  | 9.6MHz÷8   |
| 600kHz      | 0x69     | Enabled  | 4.8MHz÷8   |

## Important Notes

1. **F_CPU must match actual clock**: If you set fuses for 9.6MHz but compile with F_CPU=1200000UL, delays will be **8 times faster** than expected

2. **Power consumption**: Higher clock speeds consume more power

3. **Voltage requirements**: At higher frequencies, ensure adequate voltage (see datasheet for speed grades)

4. **After changing fuses**: The new clock speed takes effect immediately, so subsequent programming operations will use the new speed

The confusion often arises because Atmel/Microchip ships the chips with **CLKDIV8 enabled by default** for compatibility and lower power consumption, even though the oscillator itself runs at 9.6MHz.

## Important Considerations

### AVRDUDE Version Requirements
- **Atmel-ICE**: Requires AVRDUDE version **6.3 or later**
- **Microchip SNAP**: Requires AVRDUDE version **6.4 or later** (better support in **7.0+**)

Check your version:
```bash
avrdude -v
```

### Connection Speed
Both programmers may benefit from specifying a bit clock rate, especially for targets with slow clocks:
```bash
# For Atmel-ICE
avrdude -c atmelice_isp -p attiny13a -B 10 -U flash:w:blink.hex:i

# For SNAP
avrdude -c snap_isp -p attiny13a -B 10 -U flash:w:blink.hex:i
```

The ```-B``` parameter sets the ISP clock period in microseconds.

### Voltage Settings
The **SNAP programmer doesn't provide target power**, so you must power the ATtiny13A externally. The Atmel-ICE can provide power, but it's often better to use external power.

## Multiplex ATtiny13A pin
I wish to multiplex an AVR ATtiny13A pin. Provide a circuit example where the microcontroller has a pin being used as both input and output. For example, I want to measure temperature with a thermistor then light an LED based on the thermistor value, with both the thermistor and led will be on the same pin.  Explain via a circuit analysis, that the thermistor won’t be affected when the LED is lit and the LED won’t light when the thermistor is being measured via the ADC of the ATtiny13A pin.

To multiplex a pin on the ATtiny13A for both input (thermistor measurement) and output (LED control), you can use a clever circuit design that ensures the thermistor and LED do not interfere with each other. Below is an example circuit and explanation of how it works.

---

### **Circuit Design**
1. **Components**:
   - **Thermistor**: Connected in a voltage divider configuration with a resistor.
   - **LED**: Connected in series with a current-limiting resistor.
   - **ATtiny13A Pin**: Configured as an ADC input for the thermistor and as an output to drive the LED.

The 74HC4053 is a triple 2:1 analog multiplexer/demultiplexer. It has three independent switches, each with two inputs and one output. The user only needs one of these switches for their application.

## **What the 74HC4053 Is:**
It contains **three independent 2-to-1 switches** (like three SPDT switches). One switch is required for this application.

## **Simplified Connection for the Circuit:**

```
                    74HC4053
                 +------------+
Thermistor-R1 ---|Y0       COM|--- To ADC Pin
                 |            |
LED-R2 ----------|Y1        S |--- To GPIO (Select)
                 |            |
GND -------------|INH      VCC|--- 5V
                 |            |
GND -------------|VEE      GND|--- GND
                 +------------+
```

## **How It Works:**

**Pin Functions:**
- **Y0, Y1**: The two inputs being switched
- **COM**: Common output (connects to either Y0 or Y1)
- **S**: Select pin (LOW = Y0, HIGH = Y1)
- **INH**: Inhibit (tie to GND to enable the switch)
- **VEE**: Negative supply (tie to GND for single supply)

**Operation:**
- When **S = LOW**: COM connects to Y0 (thermistor circuit)
- When **S = HIGH**: COM connects to Y1 (LED circuit)

## **Your Complete Circuit:**
```
    5V                          5V
     |                           |
Thermistor                      VCC
     |                           |
     +----------Y0          74HC4053
     |           |               |
   [10k]        COM-----ADC Pin  |
     |           |               |
    GND         Y1               |
                 |               |
                LED              |
                 |               |
              [330Ω]             |
                 |               |
                GND              |
                                 |
    GPIO Pin----S                |
                                 |
    GND--------INH, VEE, GND-----+
```


## **CD74HCT4053B Complete Pinout**

* [TI CD74HCT4053B Datasheet](https://www.ti.com/lit/ds/symlink/cd74hct4053.pdf?ts=1749252478329&ref_url=https%253A%252F%252Fwww.ti.com%252Fproduct%252FCD74HCT4053)
* [TI CD74HCT4053](https://www.ti.com/product/CD74HCT4053)
```
                  CD74HCT4053B (16-pin PDIP)
                    +--------U--------+
       LED ---------|1  B1      VCC 16|------- 5V
                    |                 |
   Thermistor/10k --|2  B0       A1 15|------- NC
                    |                 |
              NC ---|3  C1       A0 14|------- NC
                    |                 |
              NC ---|4  C0    COM A 13|------- NC
                    |                 |
              NC ---|5  COM C COM B 12|------- ADC Pin
                    |                 |
             GND ---|6  INH      SA 11|------- NC
                    |                 |
             GND ---|7  VEE      SB 10|------- GPIO (Select)
                    |                 |
             GND ---|8  GND      SC  9|------- NC
                    +-----------------+
```

## **Pin Connections Summary:**

| Pin | Name | Connection |
|-----|------|------------|
| 1   | B1   | **LED anode** |
| 2   | B0   | **Thermistor/10k junction** |
| 3   | C1   | NC |
| 4   | C0   | NC |
| 5   | COM C| NC |
| 6   | INH  | **GND** (enables all switches) |
| 7   | VEE  | **GND** (for single supply) |
| 8   | GND  | **GND** |
| 9   | SC   | NC |
| 10  | SB   | **GPIO Select Pin** |
| 11  | SA   | NC |
| 12  | COM B| **ADC Pin** |
| 13  | COM A| NC |
| 14  | A0   | NC |
| 15  | A1   | NC |
| 16  | VCC  | **5V** |

**Control Logic:**
- When **SB = LOW**: COM B connects to B0 (thermistor)
- When **SB = HIGH**: COM B connects to B1 (LED)

**Notes:**
- Using only the B channel (pins 1, 2, 10, 12)
- Channels A and C are unused
- INH must be LOW to enable operation


**Software Control:**
```c
// Read temperature
digitalWrite(SELECT_PIN, LOW);  // Connect thermistor
int temp = analogRead(ADC_PIN);

// Control LED
digitalWrite(SELECT_PIN, HIGH); // Connect LED
pinMode(ADC_PIN, OUTPUT);
digitalWrite(ADC_PIN, HIGH);    // LED on
```

**Key Benefits:**
- **Complete isolation** between circuits
- **No voltage limitations**
- **No power waste**
- **Bidirectional** - can pass analog or digital signals

## Additional Elements 

* [CR2025 Vs CR2032 Batteries – Are They Interchangeable? | Battery Tools](https://batterytools.net/what-is-the-difference-between-2032-and-2025-batteries/)
* [Lithium Ion Polymer Battery with Short Cable - 3.7V 420mAh : ID 4236 : Adafruit Industries, Unique & fun DIY electronics and kits](https://www.adafruit.com/product/4236)
* [Overview | Sipping Power With NeoPixels | Adafruit Learning System](https://learn.adafruit.com/sipping-power-with-neopixels)
* [NeoPixel RGBW Mini Button PCB - Pack of 10 : ID 4776 : Adafruit Industries, Unique & fun DIY electronics and kits](https://www.adafruit.com/product/4776)


## env.make (ATtiny13A only)
```make
# Environmental variables for ATtiny13A with ATMEL-ICE
MCU = attiny13a
SERIAL = /dev/ttyACM0
F_CPU = 1200000UL
USB_BAUD = 250000UL
LIBDIR = $(DEPTH)Library
LIBRARY = no_lib
PROGRAMMER_TYPE = atmelice_isp
PROGRAMMER_ARGS = -F -V -P usb -b 115200
TOOLCHAIN =
OS =

# Environmental variables for ATtiny13A with SNAP
MCU = attiny13a
SERIAL = /dev/ttyACM0
F_CPU = 1200000UL
USB_BAUD = 250000UL
LIBDIR = $(DEPTH)Library
LIBRARY = no_lib
PROGRAMMER_TYPE = snap_isp
PROGRAMMER_ARGS = -F -V -P usb -b 115200
TOOLCHAIN =
OS =

```

## bloom.yaml 
```yaml
environments:
  default:
    shutdown_post_debug_session: true

    tool:
      name: "xplained_mini"
 
    target:
      name: "atmega328pb"
      physical_interface: "debug_wire"
      hardware_breakpoints: true
      manage_dwen_fuse_bit: true

    server:
      name: "avr_gdb_rsp"
      ip_address: "127.0.0.1"
      port: 1442

  attiny13a:
    shutdown_post_debug_session: true

    tool:
      name: "atmel_ice"
 
    target:
      name: "attiny13a"
      physical_interface: "debug_wire"
      hardware_breakpoints: true
      manage_dwen_fuse_bit: true

    server:
      name: "avr_gdb_rsp"
      ip_address: "127.0.0.1"
      port: 1442

  snap:
    shutdown_post_debug_session: true

    tool:
      name: "snap"
 
    target:
      name: "attiny13a"
      physical_interface: "debug_wire"
      hardware_breakpoints: true
      manage_dwen_fuse_bit: true

    server:
      name: "avr_gdb_rsp"
      ip_address: "127.0.0.1"
      port: 1442
```

## tasks.json

```json
{
    "version": "2.0.0",
    "tasks": [
        {
            "label": "make",
            "detail": "Run make",
            "type": "shell",
            "command": "/usr/bin/make ${input:makeTarget}",
            "options": {
                "cwd": "${fileDirname}"
            },
            "presentation": {
                "reveal": "silent",
                "panel": "shared",
                "showReuseMessage": false,
                "clear": true

              },        
            "group": {
                "kind": "build",
                "isDefault": true
            }
        }
    ],
    "inputs": [
        {
            "type": "pickString",
            "id": "makeTarget",
            "description": "Select a make target",
            "options": [
                {   
                    "value": "flash",
                    "label": "compile and upload code (upload)"
                },
                {   
                    "value": "compile",
                    "label": "only compile code (verify)"
                },
                {   
                    "value": "clean",
                    "label": "remove non-source files"
                },
                {   
                    "value": "complete",
                    "label": "complete re-compile without upload"
                },
                {   
                    "value": "verbose",
                    "label": "verbose upload to debug serial connection"
                },
                {   
                    "value": "env",
                    "label": "print env variables being used"
                },
                {   
                    "value": "size",
                    "label": "print code sizes"
                },
                {   
                    "value": "help",
                    "label": "print make commands"
                }
            ],
            "default": " flash"
        }
    ]
}
```

## Using Bloom and avr-gdb

[Bloom and ATtiny13A](https://bloom.oscillate.io/docs/target/attiny13a)

### .gdbinit - place in home folder

```
set history save on
set history size 10000
set history filename ~/.gdb_history

file main.elf
target remote :1442
set listsize 0
set tui compact-source on
tui focus cmd

define ll
load
l main
end

define td
tui disable
end

define te
tui enable
end
```


### Startup

1. In first window:
```bash
cd ATtiny
bloom snap
# bloom will initialize then wait for gdb server
```
2. In second window (remain in this window):
```
cd ATtiny/examples/blink
avr-gdb
```

### Typical gdb commands

* Once gdb has started, hit enter to get the command window
* `ll` to load main.elf and list contents
* `c` to run
* *Ctrl-c* to stop
* `mon reset` to reset PC to 0x0000
* to use register commands below, turn off *tui* using `td`
* `mon lr` to list ALL registers
* `mon rr portb` to show contents of *PORTB*, *DDRB* and *PINB*
* `mon wr portb portb 07` to set lowest 3 bits to 1

#### Example: Setting Pins
```bash
(gdb) mon wr portb portb 0
Writing value 0x00 (8-bit) to "PORTB" register, at address 0x00000038, via `data` address space...
Register written
(gdb) mon lr portb
---------- "PORTB" (`portb`) peripheral registers ----------

`portb`, `pinb`, "PINB", 0x00000036, 8-bit, "Input Pins, Port B"
`portb`, `ddrb`, "DDRB", 0x00000037, 8-bit, "Data Direction Register, Port B"
`portb`, `portb`, "PORTB", 0x00000038, 8-bit, "Data Register, Port B"

(gdb) mon rr portb
Reading "PORTB" peripheral registers...

`portb`, `pinb`, "PINB", 0x00000036, 8-bit | 0x20 (32, 0b00100000)
`portb`, `ddrb`, "DDRB", 0x00000037, 8-bit | 0x07 (7, 0b00000111)
`portb`, `portb`, "PORTB", 0x00000038, 8-bit | 0x00 (0, 0b00000000)

(gdb) mon wr portb portb 07
Writing value 0x07 (8-bit) to "PORTB" register, at address 0x00000038, via `data` address space...
Register written
```

#### Example: Setting PWM frequency
```bash
(gdb) mon lr tc0
---------- "TC0" (`tc0`) peripheral registers ----------

`tc0`, `gtccr`, "GTCCR", 0x00000048, 8-bit, "General Timer Conuter Register"
`tc0`, `ocr0b`, "OCR0B", 0x00000049, 8-bit, "Timer/Counter0 Output Compare Register"
`tc0`, `tccr0a`, "TCCR0A", 0x0000004F, 8-bit, "Timer/Counter Control Register A"
`tc0`, `tcnt0`, "TCNT0", 0x00000052, 8-bit, "Timer/Counter0"
`tc0`, `tccr0b`, "TCCR0B", 0x00000053, 8-bit, "Timer/Counter Control Register B"
`tc0`, `ocr0a`, "OCR0A", 0x00000056, 8-bit, "Timer/Counter0 Output Compare Register"
`tc0`, `tifr0`, "TIFR0", 0x00000058, 8-bit, "Timer/Counter0 Interrupt Flag register"
`tc0`, `timsk0`, "TIMSK0", 0x00000059, 8-bit, "Timer/Counter0 Interrupt Mask Register"

(gdb) mon wr tc0 ocr0a 90
Writing value 0x90 (8-bit) to "OCR0A" register, at address 0x00000056, via `data` address space...
Register written
```

